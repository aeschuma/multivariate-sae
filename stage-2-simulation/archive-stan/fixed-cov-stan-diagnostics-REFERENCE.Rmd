---
title: 'Modeling bivariate normal outcomes with fixed covariance: STAN model diagnositics'
author: "Austin Schumacher"
date: "`r Sys.Date()`"
output: 
    pdf_document:
        toc: true
        toc_depth: 4
        includes: 
            in_header: "/Users/austin/Desktop/work/presentation_publication_resources/mycommands.tex"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)

# libraries
library(rstan)
library(tidyverse)
library(haven)
library(magrittr)
library(mvtnorm)
library(Matrix)
library(bayesplot)
library(scales)

# stan options
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
```

# Notation

- $c = 1, \dots, C$ indexes cause
    - in our models, we'll set $C = 2$
- $r = 1, \dots, R$ indexes region
    - in BGD, we have $R = 8$
- $i = 1, \dots, I$ indexes REPLICATIONS 
    - in the DHS data we won't have this, i.e. N = 1
    - this is to help estimate parameters in order to see how it affects modeling
    - I'll do simulations with N = 1 as well as other values 
    - could be thought of as time period or something like that
- $N = R \times I$ is the total number of multivariate normal observations
- $\bm{y}_{ir} = (y_{ir1}, \dots, y_{irC})$ vector of our outcome variable
    - with $C = 2$, this will be modeled as bivariate normal
- $\bm{\mu}_{ir} = (\mu_{ir1}, \dots, \mu_{irC}) = \E(\bm{y})$ vector of means for which we'll be specifying models
- $\bm{V}_{ir} = \begin{bmatrix} \sigma^2_{1, ir} & \sigma_{1, ir} \sigma_{2, ir} \rho_{12,ir} & \dots \\ \sigma_{1, ir} \sigma_{2, ir} \rho_{12,ir} & \sigma^2_{2, ir} &  \\ \vdots & & \ddots \end{bmatrix}$
    - this is the FIXED covariance matrix for the multivariate observations

\newpage

# Simulation and model fitting functions (for reference)

```{r functions}
# function: 
#   simulateData()
# purpose: 
#   simulate data to fit a STAN model on 
#   for a given set of dimensions, parameters, 
#   and data generating mechanism
# input:
#   R: number of regions
#   I: number of replicationsk
#   C: number of causes
#   beta: fixed intercepts on cause
#   rho_lower, rho_upper: lower and upper bounds for correlation
#                         of fixed covariance (generated form runif())
#   sigmasq_lower, sigmasq_upper: lower and upper bounds for variance components
#                                 of fixed covariance (generated form runif())
#   sigma_gamma: SD of IID random effects (on region or on region x cause)
#   dgm: data generating mechanism, one of:
#        c("cause FE only",
#          "cause FE, region IID RE sum to zero",
#          "cause FE, region IID RE",
#          "cause FE, region x cause IID RE sum to zero",
#          "cause FE, region x cause IID RE",
#          "one cause, region IID RE sum to zero",
#          "one cause, region IID RE",
#          "cause FE, separate region IID RE by cause",
#          "cause FE, separate region IID RE by cause sum to zero",
#          "2 cause FE, shared region IID RE",
#          "2 cause FE, bivariate region IID RE",
#          "2 cause FE, bivariate region IID RE noncentered")
#   testing: logical, TRUE if you are just testing the function for troubleshooting
# output:
#   datlist: list of data to be used as input to various STAN models;
#            includes some or all of the following:
#       y: multivariate outcome as a matrix
#       N: total number of bivariate observations
#       C: number of causes
#       R: number of regions
#       I: number of replications
#       Sigma: N x C x C array with all fixed covariance matrices
#       sigma: length N vector with fixed variances in the case with only 1 cause
#       regions: vector of length N specifying which region 
#               each multivariate observation belongs to
#   params: values of parameters used in the simulation
simulateData <- function(R, I, C, 
                         beta = 1:C, 
                         rho_lower = -0.2, rho_upper = 0.2, 
                         sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                         sigma_gamma = 2,
                         lambda = NULL,
                         rho_gamma = NULL,
                         dgm,
                         seed = 8008135,
                         testing = FALSE) {
    # testing
    if (testing == TRUE) {
        R = 10
        I = 5
        C = 2
        beta = 1:C 
        rho_lower = -0.2
        rho_upper = 0.2
        sigmasq_lower = 0.05
        sigmasq_upper = 0.5
        sigma_gamma = c(1.5, 2)
        lambda = 0.5
        rho_gamma = 0.5
        seed = 8008135
        dgm = "2 cause FE, bivariate region IID RE noncentered"
    }
    
    # set seed
    set.seed(seed)
    
    # checks
    if (length(beta) != C) stop("number of betas (cause FEs) not equal to number of causes")
    if ((!C %in% c(1, 2))) stop("Only 1 or 2 causes currently supported")
    if (!(dgm %in% c("cause FE only", 
                     "cause FE, region IID RE sum to zero",
                     "cause FE, region IID RE",
                     "cause FE, region x cause IID RE sum to zero",
                     "cause FE, region x cause IID RE",
                     "one cause, region IID RE sum to zero",
                     "one cause, region IID RE",
                     "cause FE, separate region IID RE by cause",
                     "cause FE, separate region IID RE by cause sum to zero",
                     "2 cause FE, shared region IID RE",
                     "2 cause FE, bivariate region IID RE",
                     "2 cause FE, bivariate region IID RE noncentered"))) {
        stop("this data generating mechanism not supported")
    }
    if (length(sigma_gamma) > 1 & !(dgm %in% c("cause FE, separate region IID RE by cause",
                                               "cause FE, separate region IID RE by cause sum to zero",
                                               "2 cause FE, shared region IID RE",
                                               "2 cause FE, bivariate region IID RE",
                                               "2 cause FE, bivariate region IID RE noncentered"))) {
        stop(paste0("multiple sigma_gamma parameters specified which is incompatible with this data generating mechanism: ", dgm))
    }
    if (C != 1 & dgm %in% c("one cause, region IID RE sum to zero",
                           "one cause, region IID RE")) {
        stop("This dgm can only support one cause")
    }
    if (C < 2 & dgm %in% c("cause FE, separate region IID RE by cause",
                           "cause FE, separate region IID RE by cause sum to zero")) {
        stop("This dgm can only support 2 or more causes")
    } 
    if (C != 2 & dgm %in% c("2 cause FE, shared region IID RE",
                            "2 cause FE, bivariate region IID RE",
                            "2 cause FE, bivariate region IID RE noncentered")) {
        stop(paste0("Only 2 causes currently supported for dgm: ", dgm))
    }
    if (length(sigma_gamma) != C & dgm %in% c("cause FE, separate region IID RE by cause",
                                              "cause FE, separate region IID RE by cause sum to zero",
                                              "2 cause FE, shared region IID RE",
                                              "2 cause FE, bivariate region IID RE",
                                              "2 cause FE, bivariate region IID RE noncentered")) {
        stop("This dgm needs separate sigma_gamma parameters for each cause")
    }
    if (is.null(lambda) & dgm %in% c("2 cause FE, shared region IID RE")) {
        stop(paste0("need to specify lambda for dgm: ", dgm))
    }
    if (is.null(rho_gamma) & dgm %in% c("2 cause FE, bivariate region IID RE",
                                        "2 cause FE, bivariate region IID RE noncentered")) {
        stop(paste0("need to specify rho_gamma for dgm: ", dgm))
    }
    
    # parameters
    N <- R * I
    rhos <- runif(N, rho_lower, rho_upper)
    sigmas <- matrix(sqrt(runif(N * C, sigmasq_lower, sigmasq_upper)), 
                     nrow = N, ncol = C)
    
    # simulate data
    gamma_r <- rnorm(R, 0, sigma_gamma)
    if (dgm %in% c("cause FE, region IID RE sum to zero",
                   "one cause, region IID RE sum to zero")) {
        gamma_r <- gamma_r - mean(gamma_r)
    }
    gamma_rc <- rnorm(R * C, 0, sigma_gamma)
    if (dgm == "cause FE, region x cause IID RE sum to zero") {
        gamma_rc <- gamma_rc - mean(gamma_r)
    }
    regions <- rep(1:R, I)
    gamma_r_mat <- matrix(rep(rep(gamma_r, each = C), I), nrow = N, ncol = C, byrow = TRUE)
    gamma_rc_mat <- matrix(rep(gamma_rc, I), nrow = N, ncol = C, byrow = TRUE)
    if (dgm %in% c("cause FE, separate region IID RE by cause",
                   "cause FE, separate region IID RE by cause sum to zero",
                   "2 cause FE, shared region IID RE")) {
        gamma_rc <- matrix(NA, nrow = R, ncol = C)
        for (c in 1:C) {
            gamma_rc[, c] <- rnorm(R, 0, sigma_gamma[c])
            if (dgm == "cause FE, separate region IID RE by cause sum to zero") {
                gamma_rc[, c] <- gamma_rc[, c] - mean(gamma_rc[, c])
            }
        }
        gamma_rc_mat <- gamma_rc[rep(1:R, I),]
    }
    if (dgm %in% c("2 cause FE, bivariate region IID RE",
                   "2 cause FE, bivariate region IID RE noncentered")) {
        Omega <- matrix(c(1, rho_gamma, rho_gamma, 1), ncol = 2, nrow = 2)
        V <- diag(sigma_gamma, nrow = 2, ncol = 2) %*% Omega %*% diag(sigma_gamma, nrow = 2, ncol = 2)
        gamma_rc <- rmvnorm(R, rep(0, 2), V)
        gamma_rc_mat <- gamma_rc[rep(1:R, I),]
    }
    if (C == 1) {
        sigmas <- as.vector(sigmas)
        gamma_r_vec <- as.vector(gamma_r_mat)
        y <- rnorm(N, beta + gamma_r_vec, sigmas)
        
        # create data
        if (dgm %in% c("one cause, region IID RE",
                       "one cause, region IID RE sum to zero")) {
            datlist <- list(N = N,
                            R = R,
                            regions = regions,
                            sigma = sigmas,
                            y = y)
            
            # parameters to output
            params <- list(beta = beta,
                           sigma_gamma = sigma_gamma,
                           gamma_r = gamma_r)
        } else {
            stop("this data generating mechanism not yet supported for 1 cause")
        }
        
        # output
        output <- list(datlist = datlist,
                       params = params)
        
        # return the data
        return(output)
    } else {
        Sigma.array <- array(NA, dim = c(N, C, C))
        y <- matrix(NA, nrow = N, ncol = C)
        for (i in 1:N) {
            Rho <- matrix(c(1, rhos[i], rhos[i], 1), ncol = C)
            Sigma.array[i,,] <- diag(sigmas[i, ], nrow = C, ncol = C) %*% 
                Rho %*% 
                diag(sigmas[i, ], nrow = C, ncol = C)
            if (dgm == "cause FE only") {
                y[i, ] <- rmvnorm(1, beta, Sigma.array[i,,])
            } else if (dgm %in% c("cause FE, region IID RE",
                                  "cause FE, region IID RE sum to zero")) {
                y[i, ] <- rmvnorm(1, beta + gamma_r_mat[i, ], Sigma.array[i,,])
            } else if (dgm %in% c("cause FE, region x cause IID RE",
                                  "cause FE, region x cause IID RE sum to zero",
                                  "cause FE, separate region IID RE by cause",
                                  "cause FE, separate region IID RE by cause sum to zero")) {
                y[i, ] <- rmvnorm(1, beta + gamma_rc_mat[i, ], Sigma.array[i,,])
            } else if (dgm %in% c("2 cause FE, shared region IID RE")) {
                mu <- c(beta[1] + gamma_rc_mat[i, 1],
                        beta[2] + gamma_rc_mat[i, 2] + (lambda * gamma_rc_mat[i, 1]))
                y[i, ] <- rmvnorm(1, mu, Sigma.array[i,,])
            } else if (dgm %in% c("2 cause FE, bivariate region IID RE",
                                  "2 cause FE, bivariate region IID RE noncentered")) {
                mu <- c(beta[1] + gamma_rc_mat[i, 1],
                        beta[2] + gamma_rc_mat[i, 2])
                y[i, ] <- rmvnorm(1, mu, Sigma.array[i,,])
            } else {
                stop("this data generating mechanism not yet supported for multiple causes")
            }
        }
        
        # create data
        if (dgm == "cause FE only") {
            # data to be used in STAN
            datlist <- list(N = N,
                            C = C,
                            Sigma = Sigma.array,
                            y = y)
            
            # parameters to output
            params <- list(beta = beta)
        
        } else if (dgm %in% c("cause FE, region IID RE",
                              "cause FE, region IID RE sum to zero")) {
            datlist <- list(N = N,
                            R = R,
                            C = C,
                            regions = regions,
                            Sigma = Sigma.array,
                            y = y)
            
            # parameters to output
            params <- list(beta = beta,
                           sigma_gamma = sigma_gamma,
                           gamma_r = gamma_r)
        } else if (dgm %in% c("cause FE, region x cause IID RE",
                              "cause FE, region x cause IID RE sum to zero",
                              "cause FE, separate region IID RE by cause",
                              "cause FE, separate region IID RE by cause sum to zero")) {
            datlist <- list(N = N,
                            R = R,
                            C = C,
                            regions = regions,
                            Sigma = Sigma.array,
                            y = y)
            
            # parameters to output
            params <- list(beta = beta,
                           sigma_gamma = sigma_gamma,
                           gamma_rc = gamma_rc,
                           gamma_rc_mat = gamma_rc_mat)
        } else if (dgm %in% c("2 cause FE, shared region IID RE")) {
            datlist <- list(N = N,
                        R = R,
                        regions = regions,
                        Sigma = Sigma.array,
                        y = y)
            
            # parameters to output
            params <- list(beta = beta,
                           sigma_gamma = sigma_gamma,
                           gamma_rc = gamma_rc,
                           gamma_rc_mat = gamma_rc_mat,
                           lambda = lambda)
        } else if (dgm %in% c("2 cause FE, bivariate region IID RE",
                              "2 cause FE, bivariate region IID RE noncentered")) {
            datlist <- list(N = N,
                        R = R,
                        regions = regions,
                        Sigma = Sigma.array,
                        y = y)
            
            # parameters to output
            params <- list(beta = beta,
                           sigma_gamma = sigma_gamma,
                           gamma_rc = gamma_rc,
                           gamma_rc_mat = gamma_rc_mat,
                           rho_gamma = lambda)
        } else {
            stop("this data generating mechanism not yet supported for multiple causes")
        }
        
        # output
        output <- list(datlist = datlist,
                       params = params)
        
        # return the data
        return(output)
    }
}

# function: 
#   fitSTAN()
# purpose: 
#   fit a specified model in STAN with certain STAN fitting parameters and data
# input:
#   stan_model: model to be fit in STAN (matches data generating mechanism), one of:
#        c("cause FE only",
#          "cause FE, region IID RE sum to zero",
#          "cause FE, region IID RE",
#          "cause FE, region x cause IID RE sum to zero",
#          "cause FE, region x cause IID RE",
#          "one cause, region IID RE sum to zero",
#          "one cause, region IID RE",
#          "cause FE, separate region IID RE by cause",
#          "cause FE, separate region IID RE by cause sum to zero",
#          "2 cause FE, shared region IID RE",
#          "2 cause FE, bivariate region IID RE",
#          "2 cause FE, bivariate region IID RE noncentered")
#   data: list of input data for the specific STAN model
#   niter: number of TOTAL iterations for HMC
#   nchains: number of chains to run
#   nthin: number of iterations to thin
#   prop_warmup: percentage of the total iterations to use for warming up the HMC
#   max_treedepth: max treedepth for the HMC
#   inits: function defining initial values in STAN, if desired
# output:
#   list with the following components:
#       stan_file: the file for which STAN model was run
#       mod_stan: output from STAN model
#       elapsed_time: total time it took to run the STAN model
fitSTAN <- function(stan_model, data,
                    niter, nchains, nthin, prop_warmup,
                    max_treedepth = 15, adapt_delta = 0.8,
                    inits = NULL) {
    # checks
    if (!(stan_model %in% c("cause FE only", 
                     "cause FE, region IID RE sum to zero",
                     "cause FE, region IID RE",
                     "cause FE, region x cause IID RE sum to zero",
                     "cause FE, region x cause IID RE",
                     "one cause, region IID RE sum to zero",
                     "one cause, region IID RE",
                     "cause FE, separate region IID RE by cause",
                     "cause FE, separate region IID RE by cause sum to zero",
                     "2 cause FE, shared region IID RE",
                     "2 cause FE, bivariate region IID RE",
                     "2 cause FE, bivariate region IID RE noncentered"))) {
        stop("this STAN model is not supported")
    }
    
    start.time <- proc.time() 
    if (stan_model == "cause FE only") {
        stan_file <- "stan-models/fixed-cov-fe-cause.stan"
    } else if(stan_model == "cause FE, region IID RE") {
        stan_file <- "stan-models/fixed-cov-fe-cause-re-region.stan"
    } else if(stan_model == "cause FE, region IID RE sum to zero") {
        stan_file <- "stan-models/fixed-cov-fe-cause-re-regionS2Z.stan"
    } else if(stan_model == "cause FE, region x cause IID RE") {
        stan_file <- "stan-models/fixed-cov-fe-cause-re-regionXcause.stan"
    } else if(stan_model == "cause FE, region x cause IID RE sum to zero") {
        stan_file <- "stan-models/fixed-cov-fe-cause-re-regionXcauseS2Z.stan"
    } else if(stan_model == "one cause, region IID RE sum to zero") {
        stan_file <- "stan-models/fixed-var1d-fixedintercept-re-regionS2Z.stan"
    } else if(stan_model == "one cause, region IID RE") {
        stan_file <- "stan-models/fixed-var1d-fixedintercept-re-region.stan"
    } else if(stan_model == "cause FE, separate region IID RE by cause") {
        stan_file <- "stan-models/fixed-cov-fe-cause-separate-re-region.stan"
    } else if(stan_model == "cause FE, separate region IID RE by cause sum to zero") {
        stan_file <- "stan-models/fixed-cov-fe-cause-separate-re-regionS2Z.stan"
    } else if(stan_model == "2 cause FE, shared region IID RE") {
        stan_file <- "stan-models/fixed-cov-2cause-fe-shared-iid-re-region.stan"
    } else if(stan_model == "2 cause FE, bivariate region IID RE") {
        stan_file <- "stan-models/fixed-cov-2cause-fe-bivariate-iid-re-region.stan"
    } else if(stan_model == "2 cause FE, bivariate region IID RE noncentered") {
        stan_file <- "stan-models/fixed-cov-2cause-fe-bivariate-iid-re-region-noncentered.stan"
    } else {
        stop("this STAN model is not yet supported")
    }
    
    if (is.null(inits)) {
        mod_stan <- stan(file = stan_file,
                         data = data,
                         iter = niter, chains = nchains, thin = nthin, 
                         warmup = niter*prop_warmup,
                         control = list(max_treedepth = max_treedepth,
                                        adapt_delta = adapt_delta))
    } else {
        mod_stan <- stan(file = stan_file,
                         data = data,
                         iter = niter, chains = nchains, thin = nthin, 
                         warmup = niter*prop_warmup,
                         init = inits,
                         control = list(max_treedepth = max_treedepth,
                                        adapt_delta = adapt_delta))
    }
    stop.time <- proc.time()
    output <- list(stan_file = stan_file,
                   mod_stan = mod_stan,
                   elapsed_time = stop.time[3] - start.time[3])
    return(output)
}
```

\newpage

# Data with 2 causes

## Model 1: fixed intercepts on cause

The model we're generating data from is:

\eq{
    \bm{y}_{ir} | \bm\mu_{ir}, \bm{V}_{ir} &\sim N_2(\bm\mu_{ir}, \bm{V}_{ir}) \\
    \mu_{irc} &= \beta_c
}

We will fit the exact same model, with: 

Priors:

\eq{
    \beta_c &\sim N(0, sd = 5) \forall c
}

STAN model code is:

\begin{verbatim}
data {
    int<lower=1> N; // number of bivariate normal observations
    int<lower=1> ncause; // number of causes
    matrix[ncause, ncause] Sigma[N]; // fixed covariance matrices for each observed pair
    vector[ncause] y[N]; // outcome
}
parameters {
    vector[ncause] beta; // FEs on cause
}
model {
    for (i in 1:N) {
        y[i] ~ multi_normal(beta, Sigma[i]); // bivariate normal observations
    }
    beta ~ normal(0,5);
}
\end{verbatim}

\newpage

### Data dimensions: R = 10, I = 5, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$

Simulate data and run model:

```{r mod1-1, warning = TRUE}
number_of_causes <- 2
model_to_run <- "cause FE only"
simulated_data <- simulateData(R = 10, 
                               I = 5, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               seed = 8008135,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 1000, nchains = 2, nthin = 1, prop_warmup = 0.5)
# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta"))
pairs(stan_list$mod_stan, pars = c("beta"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))
```

\newpage

### Data dimensions: R = 8, I = 1, C = 2 (i.e. BGD DHS 2017 dimensions)

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$

Simulate data and run model:

```{r mod-2, warning = TRUE}
number_of_causes <- 2
model_to_run <- "cause FE only"
simulated_data <- simulateData(R = 8, 
                               I = 1, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               seed = 8008135,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 1000, nchains = 2, nthin = 1, prop_warmup = 0.5)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta"))
pairs(stan_list$mod_stan, pars = c("beta"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))
```

\newpage

### Model 1 conclusions:

\Huge

IT WORKS!

\normalsize

\newpage

## Model 2: fixed intercepts on cause, IID Normal RE on region

We will generate data as follows:

\eq{
    \bm{y}_{ir} | \bm\mu_{ir}, \bm{V}_{ir} &\sim N_2(\bm\mu_{ir}, \bm{V}_{ir}) \\
    \mu_{irc} &= \beta_c + \gamma_r \\
    \gamma_r | \sigma_{\gamma} &\overset{iid}{\sim} N(0, \sigma_{\gamma})
}

We will fit the exact same model, with:

Priors:

\eq{
    \beta_c &\sim N(0, 5) \forall c \\
    \sigma_{\gamma} &\sim \mbox{Half-t}_{\mbox{df = 3}}(0, 1)
}

STAN model code is:

\begin{verbatim}
data {
    int<lower=1> N; // number of bivariate normal observations
    int<lower=1> R; // number of regions
    int<lower=1> C; // number of causes
    int region[N]; // index for which region is for which bivariate observation
    matrix[C, C] Sigma[N]; // fixed block diagonal matrix of covariances for each observed pair
    vector[C] y[N]; // outcome
}
parameters {
    real<lower=0> sigma; // standard deviation of the IID REs on region
    real gamma[R]; // REs on region
    vector[C] beta; // FEs on cause
}
transformed parameters {
    vector[N] gamma_obs; // values of REs for each bivariate normal observation

    for (i in 1:N) {
        gamma_obs[i] = gamma[region[i]]; // repeat the correct RE for both causes
    }
}
model {
    for (i in 1:N) {
        y[i] ~ multi_normal(beta + gamma_obs[i], Sigma[i]); // bivariate normal observations
    }
    gamma ~ normal(0, sigma); // IID normal REs on region
    sigma ~ student_t(3,0,1); // leads to a half t prior on the standard deviation (because sigma is lower bounded by 0)
    beta ~ normal(0,5); // if these aren't specified then it means we have an improper uniform prior on all betas
}
\end{verbatim}

\newpage

### Data dimensions: R = 10, I = 5, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma} = 2$

Simulate data and run model:

```{r mod2-1, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 10
number_of_replications <- 5
model_to_run <- "cause FE, region IID RE"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = 2,
                               seed = 6,
                               dgm = model_to_run)

# initial values 
inits_fun <- function(chain_id){
    values <- list(sigma_gamma = 2, 
                   gamma = rep(-1, number_of_regions),
                   beta = (1:number_of_causes) + 1)
    return(values)
}

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 1000, nchains = 2, nthin = 1, prop_warmup = 0.5,
                     inits = inits_fun)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))

# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", "sigma_gamma"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
gamma_hat <- summary(stan_list$mod_stan, 
                     pars = c("gamma"), probs = 0.5)$summary[, "50%"]
plot(simulated_data$params$gamma_r ~ gamma_hat,
     xlab = "Posterior median estimated gammas",
     ylab = "True gammas")
abline(0, 1, col = "red")

# mean difference between each estimated and true gamma
mean(gamma_hat - simulated_data$params$gamma_r)
```

\newpage

## Model 2 conclusions

This is not identifiable since there is no interaction between cause and region. E.g.

$$\mu_{irc} = \beta_c + \gamma_r$$

can't be distinguished from 

$$\mu_{irc} = (\beta_c + 1) + (\gamma_r - 1)$$
for all $c$ and $r$. You can see this by the `pairs()` plot, since $\hat\beta_1$ and $\hat\beta_2$ are completely colinear, $(\hat\beta_1, \hat\beta_2) = (2, 3)$ vs. $(\beta_1, \beta_2) = (1, 2)$ (a difference of 1), and the average difference between the true and estimated $\gamma$ parameters was -1. These values ended up being the results because I set the initial values of $(\hat\beta_1, \hat\beta_2)$ to $(2, 3)$ and all the $\gamma_r$ to $-1$.

Conclusion: we need a sum-to-zero constraint on the IID REs on region (or some other constraint) for this model to work

\newpage

## Model 2b and 2c: 1-d Normal model (dead or alive, i.e. the case for one cause) with a fixed overall intercept and IID Nomal RE on region---with and without a sum to zero constraint

Fitting these model to see if the sum-to-zero constraint is necessary for the binomial fixed variance modeling case.

### Model 2b: no sum to zero constraint

For Model 2b (no sum to zero constraint) we will generate data as follows. Note the centered parameterization as discussed in Gelfand, Sahu, and Carlin (1995), which is implemented for sampling efficiency:

\eq{
    y_{ir} | \mu_{ir}, V_{ir} &\sim N(\mu_{ir}, V_{ir}) \\
    \mu_{ir} &= \gamma_r \\
    \gamma_r | \sigma_{\gamma} &\overset{iid}{\sim} N(\beta, \sigma_{\gamma})
}

We will fit the exact same model, with:

Priors:

\eq{
    \beta &\sim N(0, 5) \\
    \sigma_{\gamma} &\sim \mbox{Half-t}_{\mbox{df = 3}}(0, 1)
}

STAN model code is:

\begin{verbatim}
data {
    int<lower=1> N; // number of observations (=I*R)
    int<lower=1> R; // number of regions
    int regions[N]; // index for which region is for which observation
    vector[N] sigma; // fixed variances for each observation
    vector[N] y; // outcome
}
parameters {
    real<lower=0> sigma_gamma; // standard deviation of the IID REs on region
    real alpha[R]; // RE on region
    real beta; // fixed intercept
}
transformed parameters {
    vector[N] mu; // values of REs for each bivariate normal observation

    for (i in 1:N) {
        mu[i] = alpha[regions[i]]; // repeat the correct RE for both causes
    }
}
model {
    for (i in 1:N) {
        y[i] ~ normal(mu[i], sigma); // bivariate normal observations
    }
    alpha ~ normal(beta, sigma_gamma); // IID normal REs on region
    sigma_gamma ~ student_t(3,0,1); // leads to a half t prior
    beta ~ normal(0,5);
}
\end{verbatim}

\newpage

#### Data dimensions: R = 40, I = 15

Parameter values

- $\beta = 1$
- $\sigma^2_{ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\sigma_{\gamma} = 2$

Simulate data and run model:

```{r mod2b-1, warning = TRUE}
number_of_causes <- 1
number_of_regions <- 40
number_of_replications <- 15
model_to_run <- "one cause, region IID RE"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = 2,
                               seed = 6,
                               dgm = model_to_run)

# initial values 
inits_fun <- function(chain_id){
    values <- list(sigma_gamma = 1 + chain_id, 
                   gamma = rep(-1 * chain_id, number_of_regions),
                   beta = (1:number_of_causes) + chain_id)
    return(values)
}

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5,
                     inits = inits_fun)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))

# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta", "sigma_gamma"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot alphas vs posterior median gamma-hat
par(mfrow = c(1, 1))
alpha_hat <- summary(stan_list$mod_stan, 
                     pars = c("alpha"), probs = 0.5)$summary[, "50%"]
plot(simulated_data$params$gamma_r + simulated_data$params$beta ~ alpha_hat,
     xlab = "Posterior median estimated alphas",
     ylab = "True gammas")
abline(0, 1, col = "red")

# mean difference between each estimated and true gamma
mean(alpha_hat - simulated_data$params$gamma_r - simulated_data$params$beta)
```

\newpage

#### Data dimensions: R = 150, I = 1

Parameter values

- $\beta = 1$
- $\sigma^2_{ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\sigma_{\gamma} = 2$

Simulate data and run model:

```{r mod2b-2, warning = TRUE}
number_of_causes <- 1
number_of_regions <- 150
number_of_replications <- 1
model_to_run <- "one cause, region IID RE"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = 2,
                               seed = 6,
                               dgm = model_to_run)

# initial values 
inits_fun <- function(chain_id){
    values <- list(sigma_gamma = 1 + chain_id, 
                   gamma = rep(-1 * chain_id, number_of_regions),
                   beta = (1:number_of_causes) + chain_id)
    return(values)
}

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5,
                     inits = inits_fun)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))

# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta", "sigma_gamma"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot alphas vs posterior median gamma-hat
par(mfrow = c(1, 1))
alpha_hat <- summary(stan_list$mod_stan, 
                     pars = c("alpha"), probs = 0.5)$summary[, "50%"]
plot(simulated_data$params$gamma_r + simulated_data$params$beta ~ alpha_hat,
     xlab = "Posterior median estimated alphas",
     ylab = "True gammas")
abline(0, 1, col = "red")

# mean difference between each estimated and true gamma
mean(alpha_hat - simulated_data$params$gamma_r - simulated_data$params$beta)
```

\newpage

### Model 2c: sum to zero constraint

For Model 2c (sum to zero constraint) we will generate data as follows:

\eq{
    y_{ir} | \mu_{ir}, V_{ir} &\sim N(\mu_{ir}, V_{ir}) \\
    \mu_{ir} &= \beta + \gamma_r \\
    \gamma_r | \sigma_{\gamma} &\overset{iid}{\sim} N(0, \sigma_{\gamma}) \\
    \sum_{r = 1}^R \gamma_r &= 0
}

We will fit the same model as above, except we will use a soft sum-to-zero constraint rather than a hard constraint by specifying

\eq{
    \sum_{r = 1}^R \gamma_r &\sim N(0, 0.001 * R)
}

which is equivalent to $\E(\bm\gamma) \sim N(0,0.001)$.

Priors:

\eq{
    \beta &\sim N(0, 5) \\
    \sigma_{\gamma} &\sim \mbox{Half-t}_{\mbox{df = 3}}(0, 1)
}

STAN model code is:

\begin{verbatim}
data {
    int<lower=1> N; // number of bivariate normal observations (=I*R)
    int<lower=1> R; // number of regions
    int regions[N]; // index for which region is for which bivariate observation
    vector[N] sigma; // fixed block diagonal matrix of covariances for each observed pair
    vector[N] y; // outcome
}
parameters {
    real<lower=0> sigma_gamma; // standard deviation of the IID REs on region
    real gamma[R]; // REs on region
    real beta; // FEs on cause
}
transformed parameters {
    vector[N] gamma_obs; // values of REs for each bivariate normal observation

    for (i in 1:N) {
        gamma_obs[i] = gamma[regions[i]]; // repeat the correct RE for both causes
    }
}
model {
    for (i in 1:N) {
        y[i] ~ normal(beta + gamma_obs[i], sigma); // bivariate normal observations
    }
    gamma ~ normal(0, sigma_gamma); // IID normal REs on region
    sigma_gamma ~ student_t(3,0,1); // leads to a half t prior
    sum(gamma) ~ normal(0, 0.001 * R);  // equivalent to mean(gamma) ~ normal(0,0.001)
    beta ~ normal(0,5);
}
\end{verbatim}

\newpage

#### Data dimensions: R = 50, I = 10

Parameter values

- $\beta = 1$
- $\sigma^2_{ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\sigma_{\gamma} = 2$

Simulate data and run model:

```{r mod2c-1, warning = TRUE}
number_of_causes <- 1
number_of_regions <- 50
number_of_replications <- 10
model_to_run <- "one cause, region IID RE sum to zero"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = 2,
                               seed = 6,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))

# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta", "sigma_gamma"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
gamma_hat <- summary(stan_list$mod_stan, 
                     pars = c("gamma"), probs = 0.5)$summary[, "50%"]
plot(simulated_data$params$gamma_r ~ gamma_hat,
     xlab = "Posterior median estimated gammas",
     ylab = "True gammas")
abline(0, 1, col = "red")

# mean difference between each estimated and true gamma
mean(gamma_hat - simulated_data$params$gamma_r)
```

\newpage

#### Data dimensions: R = 150, I = 1

Parameter values

- $\beta = 1$
- $\sigma^2_{ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\sigma_{\gamma} = 2$

Simulate data and run model:

```{r mod2c-2, warning = TRUE}
number_of_causes <- 1
number_of_regions <- 150
number_of_replications <- 1
model_to_run <- "one cause, region IID RE sum to zero"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = 2,
                               seed = 6,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))

# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta", "sigma_gamma"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
gamma_hat <- summary(stan_list$mod_stan, 
                     pars = c("gamma"), probs = 0.5)$summary[, "50%"]
plot(simulated_data$params$gamma_r ~ gamma_hat,
     xlab = "Posterior median estimated gammas",
     ylab = "True gammas")
abline(0, 1, col = "red")

# mean difference between each estimated and true gamma
mean(gamma_hat - simulated_data$params$gamma_r)
```

\newpage

## Model 3: fixed intercepts on cause, IID Normal RE on region with a sum-to-zero constraint

We will generate data as follows:

\eq{
    \bm{y}_{ir} | \bm\mu_{ir}, \bm{V}_{ir} &\sim N_2(\bm\mu_{ir}, \bm{V}_{ir}) \\
    \mu_{irc} &= \beta_c + \gamma_r \\
    \gamma_r | \sigma_{\gamma} &\overset{iid}{\sim} N(0, \sigma_{\gamma}) \\
    \sum_{r = 1}^R \gamma_r &= 0
}

We will fit the same model as above, except we will use a soft sum-to-zero constraint rather than a hard constraint by specifying

\eq{
    \sum_{r = 1}^R \gamma_r &\sim N(0, 0.001 * R)
}

which is equivalent to $\E(\bm\gamma) \sim N(0,0.001)$.

Priors:

\eq{
    \beta_c &\sim N(0, 5) \forall c \\
    \sigma_{\gamma} &\sim \mbox{Half-t}_{\mbox{df = 3}}(0, 1)
}

STAN model code is:

\begin{verbatim}
data {
    int<lower=1> N; // number of bivariate normal observations
    int<lower=1> R; // number of regions
    int<lower=1> C; // number of causes
    int region[N]; // index for which region is for which bivariate observation
    matrix[C, C] Sigma[N]; // fixed block diagonal matrix of covariances for each observed pair
    vector[C] y[N]; // outcome
}
parameters {
    real<lower=0> sigma; // standard deviation of the IID REs on region
    real gamma[R]; // REs on region
    vector[C] beta; // FEs on cause
}
transformed parameters {
    vector[N] gamma_obs; // values of REs for each bivariate normal observation

    for (i in 1:N) {
        gamma_obs[i] = gamma[region[i]]; // repeat the correct RE for both causes
    }
}
model {
    for (i in 1:N) {
        y[i] ~ multi_normal(beta + gamma_obs[i], Sigma[i]); // bivariate normal observations
    }
    gamma ~ normal(0, sigma); // IID normal REs on region
    sum(gamma) ~ normal(0, 0.00001 * R);  // equivalent to mean(gamma_mat[l,]) ~ normal(0,0.00001)
    sigma ~ student_t(3,0,1); // leads to a half t prior on the standard deviation (because sigma is lower bounded by 0)
    beta ~ normal(0,5); // if these aren't specified then it means we have an improper uniform prior on all betas
}

\end{verbatim}

\newpage

### Data dimensions: R = 10, I = 5, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma} = 2$

Simulate data and run model:

```{r mod3-1, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 10
number_of_replications <- 5
model_to_run <- "cause FE, region IID RE sum to zero"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = 2,
                               seed = 6,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 1000, nchains = 2, nthin = 1, prop_warmup = 0.5)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))

# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", "sigma_gamma"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
gamma_hat <- summary(stan_list$mod_stan, 
                     pars = c("gamma"), probs = 0.5)$summary[, "50%"]
plot(simulated_data$params$gamma_r ~ gamma_hat,
     xlab = "Posterior median estimated gammas",
     ylab = "True gammas")
abline(0, 1, col = "red")

# mean difference between each estimated and true gamma
mean(gamma_hat - simulated_data$params$gamma_r)
```

\newpage

### Data dimensions: R = 8, I = 1, C = 2 (BDHS2017 dimensions)

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma} = 2$

Simulate data and run model:

```{r mod3-2, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 8
number_of_replications <- 1
model_to_run <- "cause FE, region IID RE sum to zero"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = 2,
                               seed = 6,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 1000, nchains = 2, nthin = 1, prop_warmup = 0.5)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))

# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", "sigma_gamma"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
gamma_hat <- summary(stan_list$mod_stan, 
                     pars = c("gamma"), probs = 0.5)$summary[, "50%"]
plot(simulated_data$params$gamma_r ~ gamma_hat,
     xlab = "Posterior median estimated gammas",
     ylab = "True gammas")
abline(0, 1, col = "red")

# mean difference between each estimated and true gamma
mean(gamma_hat - simulated_data$params$gamma_r)
```

\newpage

## Model 3 conclusions

This model fits! Well, the posterior distribution of $\sigma_{\gamma}$ is pretty wide.

\newpage

## Model 4: fixed intercepts on cause, IID Normal RE on region x cause 

We will generate data as follows:

\eq{
    \bm{y}_{ir} | \bm\mu_{ir}, \bm{V}_{ir} &\sim N_2(\bm\mu_{ir}, \bm{V}_{ir}) \\
    \mu_{irc} &= \beta_c + \gamma_{rc} \\
    \gamma_{rc} | \sigma_{\gamma} &\overset{iid}{\sim} N(0, \sigma_{\gamma}) \\
}

We will fit the same model.

Priors:

\eq{
    \beta_c &\sim N(0, 5) \forall c \\
    \sigma_{\gamma} &\sim \mbox{Half-t}_{\mbox{df = 3}}(0, 1)
}

STAN model code is:

\begin{verbatim}
data {
    int<lower=1> N; // number of bivariate normal observations (=I*R)
    int<lower=1> R; // number of regions
    int<lower=1> C; // number of causes
    int<lower=1> regions[N]; // index for which region is for which bivariate observation
    matrix[C, C] Sigma[N]; // fixed block diagonal matrix of covariances for each observed pair
    vector[C] y[N]; // outcome
}
parameters {
    real<lower=0> sigma_gamma; // standard deviation of the IID REs on region
    vector[C] gamma[R]; // REs on region X cause
    vector[C] beta; // FEs on cause
}
transformed parameters {
    vector[C] gamma_obs[N]; // values of REs for each bivariate normal observation

    for (i in 1:N) {
        gamma_obs[i] = gamma[regions[i]]; // repeat the correct RE for both causes
    }
}
model {
    for (i in 1:N) {
        y[i] ~ multi_normal(beta + gamma_obs[i], Sigma[i]); // bivariate normal observations
    }
    for (r in 1:R) {
        gamma[r] ~ normal(0, sigma_gamma); // IID normal REs on region
    }
    sigma_gamma ~ student_t(3,0,1); // leads to a half t prior
    beta ~ normal(0,5);
}
\end{verbatim}

\newpage

### Data dimensions: R = 20, I = 10, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma} = 2$

Simulate data and run model:

```{r mod4-1, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 20
number_of_replications <- 10
model_to_run <- "cause FE, region x cause IID RE"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = 2,
                               seed = 11,
                               dgm = model_to_run)

# initial values 
inits_fun <- function(chain_id){
    values <- list(sigma_gamma = 3 + chain_id * 2, 
                   gamma = matrix(c(2 * chain_id, -1 * chain_id), 
                                  nrow = number_of_regions, 
                                  ncol = number_of_causes),
                   beta = (1:number_of_causes) - 3 * chain_id)
    return(values)
}

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5,
                     inits = inits_fun)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))
```

```{r mod4-1-est-plots, warning = TRUE}
# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", "sigma_gamma"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
gamma_hat <- summary(stan_list$mod_stan, 
                     pars = c("gamma"), probs = 0.5)$summary[, "50%"]
par(mfrow = c(1, 1))
plot(simulated_data$params$gamma_rc ~ gamma_hat,
     xlab = "Posterior median estimated gammas",
     ylab = "True gammas", type = "n")
points(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")],
       simulated_data$params$gamma_rc[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")],
       col = alpha("dodgerblue", 0.5), pch = 19)
points(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")],
       simulated_data$params$gamma_rc[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")],
       col = alpha("indianred", 0.5), pch = 19)
abline(0, 1, col = "red")
legend("topleft", c("c = 1", "c = 2"), col = c(alpha("dodgerblue", 0.5), alpha("indianred", 0.5)), pch = 19)

# mean difference between estimated and true gamma
# all
mean(gamma_hat - as.vector(t(simulated_data$params$gamma_rc)))

# c = 1
mean(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")] - simulated_data$params$gamma_rc[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")])
mod_summary$summary
# c = 2
mean(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")] - simulated_data$params$gamma_rc[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")])

# simulated_data$params$gamma_rc
# simulated_data$params$gamma_rc_mat
# 
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
# 
# matrix(simulated_data$params$gamma_rc, nrow = 10, ncol = 2, byrow = TRUE)
# summary(stan_list$mod_stan, pars = c("gamma"), probs = c(0.1, 0.9))$summary
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
```

\newpage

### Data dimensions: R = 20, I = 50, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma} = 2$

Simulate data and run model:

```{r mod4-2, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 20
number_of_replications <- 50
model_to_run <- "cause FE, region x cause IID RE"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = 2,
                               seed = 112,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))
```

```{r mod4-2-est-plots, warning = TRUE}
# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", "sigma_gamma"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
gamma_hat <- summary(stan_list$mod_stan, 
                     pars = c("gamma"), probs = 0.5)$summary[, "50%"]
par(mfrow = c(1, 1))
plot(simulated_data$params$gamma_rc ~ gamma_hat,
     xlab = "Posterior median estimated gammas",
     ylab = "True gammas", type = "n")
points(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")],
       simulated_data$params$gamma_rc[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")],
       col = alpha("dodgerblue", 0.5), pch = 19)
points(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")],
       simulated_data$params$gamma_rc[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")],
       col = alpha("indianred", 0.5), pch = 19)
abline(0, 1, col = "red")
legend("topleft", c("c = 1", "c = 2"), col = c(alpha("dodgerblue", 0.5), alpha("indianred", 0.5)), pch = 19)

# mean difference between estimated and true gamma
# all
mean(gamma_hat - as.vector(t(simulated_data$params$gamma_rc)))

# c = 1
mean(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")] - simulated_data$params$gamma_rc[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")])
mod_summary$summary
# c = 2
mean(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")] - simulated_data$params$gamma_rc[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")])
# simulated_data$params$gamma_rc
# simulated_data$params$gamma_rc_mat
# 
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
# 
# matrix(simulated_data$params$gamma_rc, nrow = 10, ncol = 2, byrow = TRUE)
# summary(stan_list$mod_stan, pars = c("gamma"), probs = c(0.1, 0.9))$summary
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
```

\newpage

### Data dimensions: R = 100, I = 1, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma} = 2$

Simulate data and run model:

```{r mod4-3, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 100
number_of_replications <- 1
model_to_run <- "cause FE, region x cause IID RE"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = 2,
                               seed = 1122,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))
```

```{r mod4-3-est-plots, warning = TRUE}
# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", "sigma_gamma"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
gamma_hat <- summary(stan_list$mod_stan, 
                     pars = c("gamma"), probs = 0.5)$summary[, "50%"]
par(mfrow = c(1, 1))
plot(simulated_data$params$gamma_rc ~ gamma_hat,
     xlab = "Posterior median estimated gammas",
     ylab = "True gammas", type = "n")
points(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")],
       simulated_data$params$gamma_rc[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")],
       col = alpha("dodgerblue", 0.5), pch = 19)
points(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")],
       simulated_data$params$gamma_rc[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")],
       col = alpha("indianred", 0.5), pch = 19)
abline(0, 1, col = "red")
legend("topleft", c("c = 1", "c = 2"), col = c(alpha("dodgerblue", 0.5), alpha("indianred", 0.5)), pch = 19)

# mean difference between estimated and true gamma
# all
mean(gamma_hat - as.vector(t(simulated_data$params$gamma_rc)))

# c = 1
mean(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")] - simulated_data$params$gamma_rc[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")])
mod_summary$summary
# c = 2
mean(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")] - simulated_data$params$gamma_rc[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")])
# simulated_data$params$gamma_rc
# simulated_data$params$gamma_rc_mat
# 
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
# 
# matrix(simulated_data$params$gamma_rc, nrow = 10, ncol = 2, byrow = TRUE)
# summary(stan_list$mod_stan, pars = c("gamma"), probs = c(0.1, 0.9))$summary
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
```

\newpage

### Data dimensions: R = 8, I = 1, C = 2 (BGD dimensions)

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma} = 2$

Simulate data and run model:

```{r mod4-4, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 8
number_of_replications <- 1
model_to_run <- "cause FE, region x cause IID RE"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = 2,
                               seed = 1122,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 4, nthin = 1, prop_warmup = 0.5)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))
```

```{r mod4-4-est-plots, warning = TRUE}
# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", "sigma_gamma"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
gamma_hat <- summary(stan_list$mod_stan, 
                     pars = c("gamma"), probs = 0.5)$summary[, "50%"]
par(mfrow = c(1, 1))
plot(simulated_data$params$gamma_rc ~ gamma_hat,
     xlab = "Posterior median estimated gammas",
     ylab = "True gammas", type = "n")
points(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")],
       simulated_data$params$gamma_rc[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")],
       col = alpha("dodgerblue", 0.5), pch = 19)
points(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")],
       simulated_data$params$gamma_rc[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")],
       col = alpha("indianred", 0.5), pch = 19)
abline(0, 1, col = "red")
legend("topleft", c("c = 1", "c = 2"), col = c(alpha("dodgerblue", 0.5), alpha("indianred", 0.5)), pch = 19)

# mean difference between estimated and true gamma
# all
mean(gamma_hat - as.vector(t(simulated_data$params$gamma_rc)))

# c = 1
mean(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")] - simulated_data$params$gamma_rc[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")])
mod_summary$summary
# c = 2
mean(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")] - simulated_data$params$gamma_rc[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")])

# simulated_data$params$gamma_rc
# simulated_data$params$gamma_rc_mat
# 
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
# 
# matrix(simulated_data$params$gamma_rc, nrow = 10, ncol = 2, byrow = TRUE)
# summary(stan_list$mod_stan, pars = c("gamma"), probs = c(0.1, 0.9))$summary
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
```

\newpage

## Model 4 conclusions

I'm not sure yet what's going on... I think this model is good? It looks like with only 1 replication and a lot of regions, the estimates are decent. With more replications, the results get worse and there is the issue with the mean of the gammas offsetting the beta estimates. 

Notably, the $\hat\beta_c$ estimates from data of the same dimension as BGD are pretty off...

\newpage

## Model 5: fixed intercepts on cause, IID Normal RE on region x cause with a sum-to-zero constraint

We will generate data as follows:

\eq{
    \bm{y}_{ir} | \bm\mu_{ir}, \bm{V}_{ir} &\sim N_2(\bm\mu_{ir}, \bm{V}_{ir}) \\
    \mu_{irc} &= \beta_c + \gamma_{rc} \\
    \gamma_{rc} | \sigma_{\gamma} &\overset{iid}{\sim} N(0, \sigma_{\gamma}) \\
    \sum_{r = 1}^R \sum_{c = 1}^C \gamma_{rc} &= 0
}

We will fit the same model as above, except we will use a soft sum-to-zero constraint rather than a hard constraint by specifying

\eq{
    \sum_{r = 1}^R \sum_{c = 1}^C \gamma_{rc} &\sim N(0, 0.001 * R * C)
}

which is equivalent to $\E(\bm\gamma) \sim N(0,0.001)$.

Priors:

\eq{
    \beta_c &\sim N(0, 5) \forall c \\
    \sigma_{\gamma} &\sim \mbox{Half-t}_{\mbox{df = 3}}(0, 1)
}

STAN model code is:

\begin{verbatim}
data {
    int<lower=1> N; // number of bivariate normal observations (=I*R)
    int<lower=1> R; // number of regions
    int<lower=1> C; // number of causes
    int<lower=1> regions[N]; // index for which region is for which bivariate observation
    matrix[C, C] Sigma[N]; // fixed block diagonal matrix of covariances for each observed pair
    vector[C] y[N]; // outcome
}
parameters {
    real<lower=0> sigma_gamma; // standard deviation of the IID REs on region
    vector[C] gamma[R]; // REs on region X cause
    vector[C] beta; // FEs on cause
}
transformed parameters {
    vector[C] gamma_obs[N]; // values of REs for each bivariate normal observation
    matrix[R, C] gamma_tx; // matrix form of gamma for sum to zero constraint specification
    
    for (i in 1:N) {
        gamma_obs[i] = gamma[regions[i]]; // repeat the correct RE for both causes
    }
    for (r in 1:R) {
        gamma_tx[, r] = gamma[r];
    }
}
model {
    for (i in 1:N) {
        y[i] ~ multi_normal(beta + gamma_obs[i], Sigma[i]); // bivariate normal observations
    }
    for (r in 1:R) {
        gamma[r] ~ normal(0, sigma_gamma); // IID normal REs on region
    }
    to_vector(gamma_tx) ~ normal(0, 0.001 * R * C);  // equivalent to mean(gamma_tx) ~ normal(0,0.001)
    sigma_gamma ~ student_t(3,0,1); // leads to a half t prior
    beta ~ normal(0,5); 
}
\end{verbatim}

\newpage

### Data dimensions: R = 20, I = 50, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma} = 2$

Simulate data and run model:

```{r mod5-1, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 20
number_of_replications <- 50
model_to_run <- "cause FE, region x cause IID RE sum to zero"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = 2,
                               seed = 1111,
                               dgm = model_to_run)

# initial values 
# inits_fun <- function(chain_id){
#     values <- list(sigma_gamma = 3 + chain_id * 2, 
#                    gamma = matrix(c(2 * chain_id, -1 * chain_id), 
#                                   nrow = number_of_regions, 
#                                   ncol = number_of_causes),
#                    beta = (1:number_of_causes) - 3 * chain_id)
#     return(values)
# }

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))

# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma"),
                       probs = c(0.1, 0.5, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", "sigma_gamma"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
gamma_hat <- summary(stan_list$mod_stan, 
                     pars = c("gamma"), probs = 0.5)$summary[, "50%"]
plot(simulated_data$params$gamma_rc ~ gamma_hat,
     xlab = "Posterior median estimated gammas",
     ylab = "True gammas")
abline(0, 1, col = "red")

# mean difference between each estimated and true gamma
mean(gamma_hat - simulated_data$params$gamma_rc)

# simulated_data$params$gamma_rc
# simulated_data$params$gamma_rc_mat
# 
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
# 
# matrix(simulated_data$params$gamma_rc, nrow = 10, ncol = 2, byrow = TRUE)
# summary(stan_list$mod_stan, pars = c("gamma"), probs = c(0.1, 0.9))$summary
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
```

\newpage

### Data dimensions: R = 100, I = 1, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma} = 2$

Simulate data and run model:

```{r mod5-2, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 100
number_of_replications <- 1
model_to_run <- "cause FE, region x cause IID RE sum to zero"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = 2,
                               seed = 1111,
                               dgm = model_to_run)

# initial values 
# inits_fun <- function(chain_id){
#     values <- list(sigma_gamma = 3 + chain_id * 2, 
#                    gamma = matrix(c(2 * chain_id, -1 * chain_id), 
#                                   nrow = number_of_regions, 
#                                   ncol = number_of_causes),
#                    beta = (1:number_of_causes) - 3 * chain_id)
#     return(values)
# }

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))

# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma"),
                       probs = c(0.1, 0.5, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", "sigma_gamma"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
gamma_hat <- summary(stan_list$mod_stan, 
                     pars = c("gamma"), probs = 0.5)$summary[, "50%"]
plot(simulated_data$params$gamma_rc ~ gamma_hat,
     xlab = "Posterior median estimated gammas",
     ylab = "True gammas")
abline(0, 1, col = "red")

# mean difference between each estimated and true gamma
mean(gamma_hat - simulated_data$params$gamma_rc)

# simulated_data$params$gamma_rc
# simulated_data$params$gamma_rc_mat
# 
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
# 
# matrix(simulated_data$params$gamma_rc, nrow = 10, ncol = 2, byrow = TRUE)
# summary(stan_list$mod_stan, pars = c("gamma"), probs = c(0.1, 0.9))$summary
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
```

\newpage

## Model 5 conclusions

As expected (since parameter identifiability is not an issues with RxC REs),
\Huge

IT DOESN"T WORK.

\normalsize

\newpage

## Model 6: fixed intercepts on cause, separate IID Normal REs on region for each cause 

We will generate data as follows:

\eq{
    \bm{y}_{ir} | \bm\mu_{ir}, \bm{V}_{ir} &\sim N_2(\bm\mu_{ir}, \bm{V}_{ir}) \\
    \mu_{ir1} &= \beta_1 + \gamma_{1r} \\
    \mu_{ir2} &= \beta_2 + \gamma_{2r} \\
    \gamma_{1r} | \sigma_{\gamma 1} &\overset{iid}{\sim} N(0, \sigma_{\gamma 1}) \\
    \gamma_{2r} | \sigma_{\gamma 2} &\overset{iid}{\sim} N(0, \sigma_{\gamma 2}) \\
}

We will use a centered parameterization for efficiency of the HMC, fitting the following model:

\eq{
    \bm{y}_{ir} | \bm\mu_{ir}, \bm{V}_{ir} &\sim N_2(\bm\mu_{ir}, \bm{V}_{ir}) \\
    \mu_{ir1} &= \alpha_{1r} \\
    \mu_{ir2} &= \alpha_{2r} \\
    \gamma_{1r} | \beta_1, \sigma_{\gamma 1} &\overset{iid}{\sim} N(\beta_1, \sigma_{\gamma 1}) \\
    \gamma_{2r} | \beta_2, \sigma_{\gamma 2} &\overset{iid}{\sim} N(\beta_2, \sigma_{\gamma 2}) \\
}

Priors:

\eq{
    \beta_c &\sim N(0, 5) \forall c \\
    \sigma_{\gamma 1} &\sim \mbox{Half-t}_{\mbox{df = 3}}(0, 1) \\
    \sigma_{\gamma 2} &\sim \mbox{Half-t}_{\mbox{df = 3}}(0, 1)
}

STAN model code is:

\begin{verbatim}
data {
    int<lower=1> N; // number of bivariate normal observations (=I*R)
    int<lower=1> R; // number of regions
    int<lower=1> C; // number of causes
    int<lower=1> regions[N]; // index for which region is for which bivariate observation
    matrix[C, C] Sigma[N]; // fixed block diagonal matrix of covariances for each observed pair
    vector[C] y[N]; // outcome
}
parameters {
    real<lower=0> sigma_gamma[C]; // standard deviation of the IID REs on region
    matrix[R, C] alpha; // REs on region X cause
    vector[C] beta; // FEs on cause
}
transformed parameters {
    matrix[N, C] alpha_obs; // values of REs for each bivariate normal observation

    for (i in 1:N) {
        for (c in 1:C) {
             alpha_obs[i, c] = alpha[regions[i], c]; // repeat the correct RE for both causes
        }
    }
}
model {
    for (i in 1:N) {
        y[i] ~ multi_normal(to_vector(alpha_obs[i, ]), Sigma[i]); // bivariate normal observations
    }
    for (c in 1:C) {
        alpha[, c] ~ normal(beta[c], sigma_gamma[c]); // IID normal REs on region
    }
    sigma_gamma ~ student_t(3,0,1); // leads to a half t prior
    beta ~ normal(0,5); 
}
\end{verbatim}

\newpage

### Data dimensions: R = 30, I = 10, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma 1} = 1.5$
- $\sigma_{\gamma 2} = 2.5$

Simulate data and run model:

```{r mod6-1, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 30
number_of_replications <- 10
model_to_run <- "cause FE, separate region IID RE by cause"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = c(1.5, 2.5),
                               seed = 11,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))
```

```{r mod6-1-est-plots, warning = TRUE}
# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", 
                    "sigma_gamma[1]", "sigma_gamma[2]"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
alpha_hat <- summary(stan_list$mod_stan, 
                     pars = c("alpha"), probs = 0.5)$summary[, "50%"]
mean(alpha_hat)
mean(alpha_hat[which(substr(names(alpha_hat), nchar(names(alpha_hat))-2, nchar(names(alpha_hat))) == ",1]")])
mean(alpha_hat[which(substr(names(alpha_hat), nchar(names(alpha_hat))-2, nchar(names(alpha_hat))) == ",2]")])
# par(mfrow = c(1, 1))
# plot(as.vector(t(simulated_data$params$gamma_rc)) ~ alpha_hat,
#      xlab = "Posterior median estimated alphas",
#      ylab = "True alphas", type = "n")
# points(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")],
#        as.vector(simulated_data$params$gamma_rc[, 1]),
#        col = alpha("dodgerblue", 0.5), pch = 19)
# points(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")],
#        as.vector(simulated_data$params$gamma_rc[, 2]),
#        col = alpha("indianred", 0.5), pch = 19)
# abline(0, 1, col = "red")
# legend("topleft", c("c = 1", "c = 2"), col = c(alpha("dodgerblue", 0.5), alpha("indianred", 0.5)), pch = 19)
# 
# # mean difference between estimated and true gamma
# # all
# mean(gamma_hat - as.vector(t(simulated_data$params$gamma_rc)))
# 
# # c = 1
# mean(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")] - as.vector(simulated_data$params$gamma_rc[, 1]))
# 
# # c = 2
# mean(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")] - as.vector(simulated_data$params$gamma_rc[, 2]))

# simulated_data$params$gamma_rc
# simulated_data$params$gamma_rc_mat
# 
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
# 
# matrix(simulated_data$params$gamma_rc, nrow = 10, ncol = 2, byrow = TRUE)
# summary(stan_list$mod_stan, pars = c("gamma"), probs = c(0.1, 0.9))$summary
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
```

\newpage

### Data dimensions: R = 90, I = 1, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma 1} = 1.5$
- $\sigma_{\gamma 2} = 2.5$

Simulate data and run model:

```{r mod6-2, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 90
number_of_replications <- 1
model_to_run <- "cause FE, separate region IID RE by cause"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = c(1.5, 2.5),
                               seed = 11,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))
```

```{r mod6-2-est-plots, warning = TRUE}
# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", 
                    "sigma_gamma[1]", "sigma_gamma[2]"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
alpha_hat <- summary(stan_list$mod_stan, 
                     pars = c("alpha"), probs = 0.5)$summary[, "50%"]

mean(alpha_hat)
mean(alpha_hat[which(substr(names(alpha_hat), nchar(names(alpha_hat))-2, nchar(names(alpha_hat))) == ",1]")])
mean(alpha_hat[which(substr(names(alpha_hat), nchar(names(alpha_hat))-2, nchar(names(alpha_hat))) == ",2]")])
# par(mfrow = c(1, 1))
# plot(as.vector(t(simulated_data$params$gamma_rc)) ~ gamma_hat,
#      xlab = "Posterior median estimated gammas",
#      ylab = "True gammas", type = "n")
# points(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")],
#        as.vector(simulated_data$params$gamma_rc[, 1]),
#        col = alpha("dodgerblue", 0.5), pch = 19)
# points(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")],
#        as.vector(simulated_data$params$gamma_rc[, 2]),
#        col = alpha("indianred", 0.5), pch = 19)
# abline(0, 1, col = "red")
# legend("topleft", c("c = 1", "c = 2"), col = c(alpha("dodgerblue", 0.5), alpha("indianred", 0.5)), pch = 19)
# 
# # mean difference between estimated and true gamma
# # all
# mean(gamma_hat - as.vector(t(simulated_data$params$gamma_rc)))
# 
# # c = 1
# mean(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")] - as.vector(simulated_data$params$gamma_rc[, 1]))
# 
# # c = 2
# mean(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")] - as.vector(simulated_data$params$gamma_rc[, 2]))

# simulated_data$params$gamma_rc
# simulated_data$params$gamma_rc_mat
# 
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
# 
# matrix(simulated_data$params$gamma_rc, nrow = 10, ncol = 2, byrow = TRUE)
# summary(stan_list$mod_stan, pars = c("gamma"), probs = c(0.1, 0.9))$summary
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
```

\newpage

### Data dimensions: R = 8, I = 1, C = 2 (BGD dimensions)

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma 1} = 1.5$
- $\sigma_{\gamma 2} = 2.5$

Simulate data and run model:

```{r mod6-3, warning = TRUE}
number_of_regions <- 8
number_of_causes <- 2
number_of_replications <- 1
model_to_run <- "cause FE, separate region IID RE by cause"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = c(1.5, 2.5),
                               seed = 11,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}

cat(paste("Elapsed time:", time_report))
```

```{r mod6-3-est-plots, warning = TRUE}
# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", 
                    "sigma_gamma[1]", "sigma_gamma[2]"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
# plot gammas vs posterior median gamma-hat
alpha_hat <- summary(stan_list$mod_stan, 
                     pars = c("alpha"), probs = 0.5)$summary[, "50%"]

mean(alpha_hat)
mean(alpha_hat[which(substr(names(alpha_hat), nchar(names(alpha_hat))-2, nchar(names(alpha_hat))) == ",1]")])
mean(alpha_hat[which(substr(names(alpha_hat), nchar(names(alpha_hat))-2, nchar(names(alpha_hat))) == ",2]")])
# 
# par(mfrow = c(1, 1))
# plot(as.vector(t(simulated_data$params$gamma_rc)) ~ gamma_hat,
#      xlab = "Posterior median estimated gammas",
#      ylab = "True gammas", type = "n")
# points(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")],
#        as.vector(simulated_data$params$gamma_rc[, 1]),
#        col = alpha("dodgerblue", 0.5), pch = 19)
# points(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")],
#        as.vector(simulated_data$params$gamma_rc[, 2]),
#        col = alpha("indianred", 0.5), pch = 19)
# abline(0, 1, col = "red")
# legend("topleft", c("c = 1", "c = 2"), col = c(alpha("dodgerblue", 0.5), alpha("indianred", 0.5)), pch = 19)
# 
# # mean difference between estimated and true gamma
# # all
# mean(gamma_hat - as.vector(t(simulated_data$params$gamma_rc)))
# 
# # c = 1
# mean(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")] - as.vector(simulated_data$params$gamma_rc[, 1]))
# 
# # c = 2
# mean(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")] - as.vector(simulated_data$params$gamma_rc[, 2]))

# simulated_data$params$gamma_rc
# simulated_data$params$gamma_rc_mat
# 
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
# 
# matrix(simulated_data$params$gamma_rc, nrow = 10, ncol = 2, byrow = TRUE)
# summary(stan_list$mod_stan, pars = c("gamma"), probs = c(0.1, 0.9))$summary
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
```

## Model 6: conclusions

Looks good!

## Model 7: fixed intercepts on cause, separate IID Normal REs on region for each cause with sum to zero constraints

We will generate data as follows:

\eq{
    \bm{y}_{ir} | \bm\mu_{ir}, \bm{V}_{ir} &\sim N_2(\bm\mu_{ir}, \bm{V}_{ir}) \\
    \mu_{ir1} &= \beta_1 + \gamma_{1r} \\
    \mu_{ir2} &= \beta_2 + \gamma_{2r} \\
    \gamma_{1r} | \sigma_{\gamma 1} &\overset{iid}{\sim} N(0, \sigma_{\gamma 1}) \\
    \gamma_{2r} | \sigma_{\gamma 2} &\overset{iid}{\sim} N(0, \sigma_{\gamma 2}) \\
    \sum_{r = 1}^R \gamma_{1r} &= 0 \\
    \sum_{r = 1}^R \gamma_{2r} &= 0
}

We will fit the same model, except with soft sum to zero constraints rather than hard ones.

Priors:

\eq{
    \beta_c &\sim N(0, 5) \forall c \\
    \sigma_{\gamma 1} &\sim \mbox{Half-t}_{\mbox{df = 3}}(0, 1) \\
    \sigma_{\gamma 2} &\sim \mbox{Half-t}_{\mbox{df = 3}}(0, 1)
}

STAN model code is:

\begin{verbatim}
data {
    int<lower=1> N; // number of bivariate normal observations (=I*R)
    int<lower=1> R; // number of regions
    int<lower=1> C; // number of causes
    int<lower=1> regions[N]; // index for which region is for which bivariate observation
    matrix[C, C] Sigma[N]; // fixed block diagonal matrix of covariances for each observed pair
    vector[C] y[N]; // outcome
}
parameters {
    real<lower=0> sigma_gamma[C]; // standard deviation of the IID REs on region
    matrix[R, C] gamma; // REs on region X cause
    vector[C] beta; // FEs on cause
}
transformed parameters {
    matrix[N, C] gamma_obs; // values of REs for each bivariate normal observation

    for (i in 1:N) {
        for (c in 1:C) {
             gamma_obs[i, c] = gamma[regions[i], c]; // repeat the correct RE for both causes
        }
    }
}
model {
    for (i in 1:N) {
        y[i] ~ multi_normal(beta + to_vector(gamma_obs[i, ]), Sigma[i]); // bivariate normal observations
    }
    for (c in 1:C) {
        gamma[, c] ~ normal(0, sigma_gamma[c]); // IID normal REs on region
        sum(gamma[, c]) ~ normal(0, 0.0001 * R);  // equivalent to mean(gamma) ~ normal(0,0.0001)
    }
    sigma_gamma ~ student_t(3,0,1); // leads to a half t prior
    beta ~ normal(0,5); 
}
\end{verbatim}

\newpage

### Data dimensions: R = 20, I = 10, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma 1} = 1.5$
- $\sigma_{\gamma 2} = 2.5$

Simulate data and run model:

```{r mod7-1, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 20
number_of_replications <- 10
model_to_run <- "cause FE, separate region IID RE by cause sum to zero"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = c(1.5, 2.5),
                               seed = 11,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))
```

```{r mod7-1-est-plots, warning = TRUE}
# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", 
                    "sigma_gamma[1]", "sigma_gamma[2]"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
gamma_hat <- summary(stan_list$mod_stan, 
                     pars = c("gamma"), probs = 0.5)$summary[, "50%"]

par(mfrow = c(1, 1))
plot(as.vector(t(simulated_data$params$gamma_rc)) ~ gamma_hat,
     xlab = "Posterior median estimated gammas",
     ylab = "True gammas", type = "n")
points(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")],
       as.vector(simulated_data$params$gamma_rc[, 1]),
       col = alpha("dodgerblue", 0.5), pch = 19)
points(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")],
       as.vector(simulated_data$params$gamma_rc[, 2]),
       col = alpha("indianred", 0.5), pch = 19)
abline(0, 1, col = "red")
legend("topleft", c("c = 1", "c = 2"), col = c(alpha("dodgerblue", 0.5), alpha("indianred", 0.5)), pch = 19)

# mean difference between estimated and true gamma
# all
mean(gamma_hat - as.vector(t(simulated_data$params$gamma_rc)))

# c = 1
mean(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")] - as.vector(simulated_data$params$gamma_rc[, 1]))

# c = 2
mean(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")] - as.vector(simulated_data$params$gamma_rc[, 2]))

# simulated_data$params$gamma_rc
# simulated_data$params$gamma_rc_mat
# 
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
# 
# matrix(simulated_data$params$gamma_rc, nrow = 10, ncol = 2, byrow = TRUE)
# summary(stan_list$mod_stan, pars = c("gamma"), probs = c(0.1, 0.9))$summary
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
```

\newpage

### Data dimensions: R = 100, I = 1, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma 1} = 1.5$
- $\sigma_{\gamma 2} = 2.5$

Simulate data and run model:

```{r mod7-2, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 100
number_of_replications <- 1
model_to_run <- "cause FE, separate region IID RE by cause sum to zero"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = c(1.5, 2.5),
                               seed = 11,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))
```

```{r mod7-2-est-plots, warning = TRUE}
# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", 
                    "sigma_gamma[1]", "sigma_gamma[2]"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
gamma_hat <- summary(stan_list$mod_stan, 
                     pars = c("gamma"), probs = 0.5)$summary[, "50%"]
par(mfrow = c(1, 1))
plot(as.vector(t(simulated_data$params$gamma_rc)) ~ gamma_hat,
     xlab = "Posterior median estimated gammas",
     ylab = "True gammas", type = "n")
points(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")],
       as.vector(simulated_data$params$gamma_rc[, 1]),
       col = alpha("dodgerblue", 0.5), pch = 19)
points(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")],
       as.vector(simulated_data$params$gamma_rc[, 2]),
       col = alpha("indianred", 0.5), pch = 19)
abline(0, 1, col = "red")
legend("topleft", c("c = 1", "c = 2"), col = c(alpha("dodgerblue", 0.5), alpha("indianred", 0.5)), pch = 19)

# mean difference between estimated and true gamma
# all
mean(gamma_hat - as.vector(t(simulated_data$params$gamma_rc)))

# c = 1
mean(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")] - as.vector(simulated_data$params$gamma_rc[, 1]))

# c = 2
mean(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")] - as.vector(simulated_data$params$gamma_rc[, 2]))

# simulated_data$params$gamma_rc
# simulated_data$params$gamma_rc_mat
# 
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
# 
# matrix(simulated_data$params$gamma_rc, nrow = 10, ncol = 2, byrow = TRUE)
# summary(stan_list$mod_stan, pars = c("gamma"), probs = c(0.1, 0.9))$summary
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
```

\newpage

### Data dimensions: R = 8, I = 1, C = 2 (BGD dimensions)

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma 1} = 1.5$
- $\sigma_{\gamma 2} = 2.5$

Simulate data and run model:

```{r mod7-3, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 8
number_of_replications <- 1
model_to_run <- "cause FE, separate region IID RE by cause sum to zero"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = c(1.5, 2.5),
                               seed = 11,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))
```

```{r mod7-3-est-plots, warning = TRUE}
# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", 
                    "sigma_gamma[1]", "sigma_gamma[2]"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
gamma_hat <- summary(stan_list$mod_stan, 
                     pars = c("gamma"), probs = 0.5)$summary[, "50%"]
par(mfrow = c(1, 1))
plot(as.vector(t(simulated_data$params$gamma_rc)) ~ gamma_hat,
     xlab = "Posterior median estimated gammas",
     ylab = "True gammas", type = "n")
points(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")],
       as.vector(simulated_data$params$gamma_rc[, 1]),
       col = alpha("dodgerblue", 0.5), pch = 19)
points(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")],
       as.vector(simulated_data$params$gamma_rc[, 2]),
       col = alpha("indianred", 0.5), pch = 19)
abline(0, 1, col = "red")
legend("topleft", c("c = 1", "c = 2"), col = c(alpha("dodgerblue", 0.5), alpha("indianred", 0.5)), pch = 19)

# mean difference between estimated and true gamma
# all
mean(gamma_hat - as.vector(t(simulated_data$params$gamma_rc)))

# c = 1
mean(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")] - as.vector(simulated_data$params$gamma_rc[, 1]))

# c = 2
mean(gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")] - as.vector(simulated_data$params$gamma_rc[, 2]))

# simulated_data$params$gamma_rc
# simulated_data$params$gamma_rc_mat
# 
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
# 
# matrix(simulated_data$params$gamma_rc, nrow = 10, ncol = 2, byrow = TRUE)
# summary(stan_list$mod_stan, pars = c("gamma"), probs = c(0.1, 0.9))$summary
# summary(stan_list$mod_stan, pars = c("gamma_obs"), probs = c(0.1, 0.9))$summary
```

## Model 7: conclusions

These results look great!

## Model 8: fixed intercepts on cause, shared IID Normal REs on region

We will generate data as follows:

\eq{
    \bm{y}_{ir} | \bm\mu_{ir}, \bm{V}_{ir} &\sim N_2(\bm\mu_{ir}, \bm{V}_{ir}) \\
    \mu_{ir1} &= \beta_1 + \gamma_{1r} \\
    \mu_{ir2} &= \beta_2 + \gamma_{2r} + \lambda \gamma_{1r} \\
    \gamma_{1r} | \sigma_{\gamma 1} &\overset{iid}{\sim} N(0, \sigma_{\gamma 1}) \\
    \gamma_{2r} | \sigma_{\gamma 2} &\overset{iid}{\sim} N(0, \sigma_{\gamma 2}) 
}

We will fit a model with a centered parameterization for efficiency of the HMC, i.e.

\eq{
    \bm{y}_{ir} | \bm\mu_{ir}, \bm{V}_{ir} &\sim N_2(\bm\mu_{ir}, \bm{V}_{ir}) \\
    \mu_{ir1} &= \alpha_{1r} \\
    \mu_{ir2} &= \alpha_{2r} + \lambda (\alpha_{1r} - \beta_1) \\
    \alpha_{1r} | \beta_1, \sigma_{\gamma 1} &\overset{iid}{\sim} N(\beta_1, \sigma_{\gamma 1}) \\
    \alpha_{2r} | \beta_2, \sigma_{\gamma 2} &\overset{iid}{\sim} N(\beta_2, \sigma_{\gamma 2}) 
}

Priors:

\eq{
    \beta_c &\sim N(0, 5) \forall c \\
    \sigma_{\gamma 1} &\sim \mbox{Half-t}_{\mbox{df = 3}}(0, 1) \\
    \sigma_{\gamma 2} &\sim \mbox{Half-t}_{\mbox{df = 3}}(0, 1) \\
    \lambda &\sim N(0,1)
}

STAN model code is:

\begin{verbatim}
data {
    int<lower=1> N; // number of bivariate normal observations (=I*R)
    int<lower=1> R; // number of regions
    int<lower=1> regions[N]; // index for which region is for which bivariate observation
    matrix[2, 2] Sigma[N]; // fixed block diagonal matrix of covariances for each observed pair
    vector[2] y[N]; // outcome
}
parameters {
    real<lower=0> sigma_gamma[2]; // standard deviation of the IID REs on region
    vector[R] alpha1; // REs on region for cause 1 (shared)
    vector[R] alpha2; // RE on region for cause 2
    vector[2] beta; // FEs on cause
    real lambda; // coefficient on shared component
}
transformed parameters {
    matrix[N, 2] mu; // means of bivariate normal obs

    for (i in 1:N) {
         mu[i, 1] = alpha1[regions[i]]; //
         mu[i, 2] = alpha2[regions[i]] + (lambda * (alpha1[regions[i]] - beta[1])); //
    }
}
model {
    for (i in 1:N) {
        y[i] ~ multi_normal(to_vector(mu[i]), Sigma[i]); // bivariate normal observations
    }
    alpha1 ~ normal(beta[1], sigma_gamma[1]); // IID normal REs on region
    alpha2 ~ normal(beta[2], sigma_gamma[2]); // IID normal REs on region
    sigma_gamma ~ student_t(3,0,1); // leads to a half t prior
    beta ~ normal(0,5); 
}
\end{verbatim}

### Data dimensions: R = 30, I = 10, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma 1} = 1.5$
- $\sigma_{\gamma 2} = 2.5$
- $\lambda = 0.5$

Simulate data and run model:

```{r mod8-1, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 30
number_of_replications <- 10
model_to_run <-  "2 cause FE, shared region IID RE"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = c(1.5, 2.5),
                               lambda = 0.5,
                               seed = 111,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))
```

```{r mod8-1-est-plots, warning = TRUE}
# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma", "lambda"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma", "lambda"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma", "lambda"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", 
                    "sigma_gamma[1]", "sigma_gamma[2]",
                    "lambda"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
alpha_hat1 <- summary(stan_list$mod_stan, 
                     pars = c("alpha1"), probs = 0.5)$summary[, "50%"]
alpha_hat2 <- summary(stan_list$mod_stan, 
                     pars = c("alpha2"), probs = 0.5)$summary[, "50%"]
mean(alpha_hat1)
mean(alpha_hat2)
par(mfrow = c(1, 2), mar = c(5, 4, 4, 2), oma = c(1, 1, .25, .25))
plot((simulated_data$params$gamma_rc[,1] + simulated_data$params$beta[1]) ~ alpha_hat1,
     xlab = "Cause 1",
     ylab = "True alphas", 
     main = "Posterior median of the alphas",
     pch = 19, col = alpha("dodgerblue", 0.5))
abline(0, 1, col = "darkgreen")
plot((simulated_data$params$gamma_rc[,2] + simulated_data$params$beta[2]) ~ alpha_hat2,
     xlab = "Cause 2",
     ylab = "True alphas", 
     pch = 19, col = alpha("indianred", 0.5))
abline(0, 1, col = "darkgreen")
```

\newpage

### Data dimensions: R = 100, I = 1, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma 1} = 1.5$
- $\sigma_{\gamma 2} = 2.5$
- $\lambda = 0.5$

Simulate data and run model:

```{r mod8-2, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 100
number_of_replications <- 1
model_to_run <-  "2 cause FE, shared region IID RE"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = c(1.5, 2.5),
                               lambda = 0.5,
                               seed = 4,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))
```

```{r mod8-2-est-plots, warning = TRUE}
# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma", "lambda"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma", "lambda"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma", "lambda"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", 
                    "sigma_gamma[1]", "sigma_gamma[2]",
                    "lambda"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
alpha_hat1 <- summary(stan_list$mod_stan, 
                     pars = c("alpha1"), probs = 0.5)$summary[, "50%"]
alpha_hat2 <- summary(stan_list$mod_stan, 
                     pars = c("alpha2"), probs = 0.5)$summary[, "50%"]
mean(alpha_hat1)
mean(alpha_hat2)
par(mfrow = c(1, 2), mar = c(5, 4, 4, 2), oma = c(1, 1, .25, .25))
plot((simulated_data$params$gamma_rc[,1] + simulated_data$params$beta[1]) ~ alpha_hat1,
     xlab = "Cause 1",
     ylab = "True alphas", 
     main = "Posterior median of the alphas",
     pch = 19, col = alpha("dodgerblue", 0.5))
abline(0, 1, col = "darkgreen")
plot((simulated_data$params$gamma_rc[,2] + simulated_data$params$beta[2]) ~ alpha_hat2,
     xlab = "Cause 2",
     ylab = "True alphas", 
     pch = 19, col = alpha("indianred", 0.5))
abline(0, 1, col = "black")
```

\newpage

### Data dimensions: R = 8, I = 1, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma 1} = 1.5$
- $\sigma_{\gamma 2} = 2.5$
- $\lambda = 0.5$

Simulate data and run model:

```{r mod8-3, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 8
number_of_replications <- 1
model_to_run <-  "2 cause FE, shared region IID RE"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = c(1.5, 2.5),
                               lambda = 0.5,
                               seed = 2,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 15000, nchains = 2, nthin = 1, prop_warmup = 0.5,
                     max_treedepth = 25, adapt_delta = 0.95)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))
```

```{r mod8-3-est-plots, warning = TRUE}
# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma", "lambda"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma", "lambda"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma", "lambda"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", 
                    "sigma_gamma[1]", "sigma_gamma[2]",
                    "lambda"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
alpha_hat1 <- summary(stan_list$mod_stan, 
                     pars = c("alpha1"), probs = 0.5)$summary[, "50%"]
alpha_hat2 <- summary(stan_list$mod_stan, 
                     pars = c("alpha2"), probs = 0.5)$summary[, "50%"]
mean(alpha_hat1)
mean(alpha_hat2)
par(mfrow = c(1, 2), mar = c(5, 4, 4, 2), oma = c(1, 1, .25, .25))
plot((simulated_data$params$gamma_rc[,1] + simulated_data$params$beta[1]) ~ alpha_hat1,
     xlab = "Cause 1",
     ylab = "True alphas", 
     main = "Posterior median of the alphas",
     pch = 19, col = alpha("dodgerblue", 0.5))
abline(0, 1, col = "darkgreen")
plot((simulated_data$params$gamma_rc[,2] + simulated_data$params$beta[2]) ~ alpha_hat2,
     xlab = "Cause 2",
     ylab = "True alphas", 
     pch = 19, col = alpha("indianred", 0.5))
abline(0, 1, col = "darkgreen")
```

\newpage

## Model 8: conclusions

These results look good for larger amounts of data. For the case with data of the same dimension as BGD.... not really the best estimates.

## Model 9: fixed intercepts on cause, bivariate Normal REs on region (2 causes)

We will generate data as follows:

\eq{
    \bm{y}_{ir} | \bm\mu_{ir}, \bm{V}_{ir} &\sim N_2(\bm\mu_{ir}, \bm{V}_{ir}) \\
    \mu_{ir1} &= \beta_1 + \gamma_{1r} \\
    \mu_{ir2} &= \beta_2 + \gamma_{2r}\\
    (\gamma_{1r}, \gamma_{2r}) | \bm\Sigma_{\gamma} &\overset{iid}{\sim} N_2(0, \bm\Sigma_{\gamma})
}

We will fit a model with a centered parameterization for efficiency of the HMC, i.e.

\eq{
    \bm{y}_{ir} | \bm\mu_{ir}, \bm{V}_{ir} &\sim N_2(\bm\mu_{ir}, \bm{V}_{ir}) \\
    \mu_{ir1} &= \alpha_{1r} \\
    \mu_{ir2} &= \alpha_{2r} \\
    (\alpha_{1r}, \alpha_{2r}) | \bm\Sigma_{\gamma} &\overset{iid}{\sim} N_2(\bm\beta, \bm\Sigma_{\gamma}) \\
    \Sigma_{\gamma} &= \bm{S} \Omega \bm{S} \\
    \bm{S} &= \begin{bmatrix} \sigma_{\gamma 1} & 0 \\ 0 & \sigma_{\gamma 2} \end{bmatrix} \\
    \Omega &= \begin{bmatrix} 1 & \rho_{\gamma} \\ \rho_{\gamma} & 1 \end{bmatrix} 
}

Priors:

\eq{
    \beta_c &\sim N(0, 5) \forall c \\
    \sigma_{\gamma 1} &\sim \mbox{Half-t}_{\mbox{df = 3}}(0, 1) \\
    \sigma_{\gamma 2} &\sim \mbox{Half-t}_{\mbox{df = 3}}(0, 1) \\
    \Omega &= \bm{L}\bm{L}^T \text{ (Cholesky decomposition)} \\
    L &\sim \mbox{LKJ}(1)
}

STAN model code is:

\begin{verbatim}
data {
    int<lower=1> N; // number of bivariate normal observations (=I*R)
    int<lower=1> R; // number of regions
    int<lower=1> regions[N]; // index for which region is for which bivariate observation
    matrix[2, 2] Sigma[N]; // fixed block diagonal matrix of covariances for each observed pair
    vector[2] y[N]; // outcome
}
parameters {
    vector<lower=0>[2] sigma_gamma; // standard deviations of the IID REs on region
    vector[2] alpha[R]; // REs on region for cause 1 
    vector[2] beta; // FEs on cause
    cholesky_factor_corr[2] Lcorr;// cholesky factor (L_u matrix for Omega)
}
transformed parameters {
    vector[2] mu[N]; // means of bivariate normal obs
    corr_matrix[2] Omega; // correlation matrix for REs
    cov_matrix[2] V; // covaraince matrix for REs
    
    Omega = multiply_lower_tri_self_transpose(Lcorr);
    V = quad_form_diag(Omega, sigma_gamma); // quad_form_diag: diag_matrix(sig) * R * diag_matrix(sig)
    for (i in 1:N) {
         mu[i] = alpha[regions[i]]; //
    }
}
model {
    for (i in 1:N) {
        y[i] ~ multi_normal(to_vector(mu[i]), Sigma[i]); // bivariate normal observations
    }
    alpha ~ multi_normal(beta, V); // IID normal REs on region
    Lcorr ~ lkj_corr_cholesky(1); 
    sigma_gamma ~ student_t(3,0,1); // leads to a half t prior
    beta ~ normal(0,5); 
}
\end{verbatim}

### Data dimensions: R = 30, I = 10, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma 1} = 1.5$
- $\sigma_{\gamma 2} = 2.5$
- $\rho = 0.5$

Simulate data and run model:

```{r mod9-1, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 30
number_of_replications <- 10
model_to_run <-  "2 cause FE, bivariate region IID RE"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = c(1.5, 2.5),
                               rho_gamma = 0.5,
                               seed = 111,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))
```

```{r mod9-1-est-plots, warning = TRUE}
# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma", "Omega[1,2]"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma", "Lcorr[2,1]", "Lcorr[2,2]"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma", "Lcorr[2,1]", "Lcorr[2,2]"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", 
                    "sigma_gamma[1]", "sigma_gamma[2]",
                    "Lcorr[2,1]", "Lcorr[2,2]"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
alpha_hat <- summary(stan_list$mod_stan, 
                     pars = c("alpha"), probs = 0.5)$summary[, "50%"]

alpha_hat1 <- alpha_hat[which(substr(names(alpha_hat), nchar(names(alpha_hat))-2, nchar(names(alpha_hat))) == ",1]")]
alpha_hat2 <- alpha_hat[which(substr(names(alpha_hat), nchar(names(alpha_hat))-2, nchar(names(alpha_hat))) == ",2]")]

mean(alpha_hat1)
mean(alpha_hat2)
par(mfrow = c(1, 2), mar = c(5, 4, 4, 2), oma = c(1, 1, .25, .25))
plot((simulated_data$params$gamma_rc[,1] + simulated_data$params$beta[1]) ~ alpha_hat1,
     xlab = "Cause 1",
     ylab = "True alphas", 
     main = "Posterior median of the alphas",
     pch = 19, col = alpha("dodgerblue", 0.5))
abline(0, 1, col = "darkgreen")
plot((simulated_data$params$gamma_rc[,2] + simulated_data$params$beta[2]) ~ alpha_hat2,
     xlab = "Cause 2",
     ylab = "True alphas", 
     pch = 19, col = alpha("indianred", 0.5))
abline(0, 1, col = "darkgreen")
```

\newpage

### Data dimensions: R = 100, I = 1, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma 1} = 1.5$
- $\sigma_{\gamma 2} = 2.5$
- $\rho = 0.5$

Simulate data and run model:

```{r mod9-2, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 100
number_of_replications <- 1
model_to_run <-  "2 cause FE, bivariate region IID RE"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = c(1.5, 2.5),
                               rho_gamma = 0.5,
                               seed = 111,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))
```

```{r mod9-2-est-plots, warning = TRUE}
# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma", "Omega[1,2]"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma", "Lcorr[2,1]", "Lcorr[2,2]"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma", "Lcorr[2,1]", "Lcorr[2,2]"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", 
                    "sigma_gamma[1]", "sigma_gamma[2]",
                    "Lcorr[2,1]", "Lcorr[2,2]"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
alpha_hat <- summary(stan_list$mod_stan, 
                     pars = c("alpha"), probs = 0.5)$summary[, "50%"]

alpha_hat1 <- alpha_hat[which(substr(names(alpha_hat), nchar(names(alpha_hat))-2, nchar(names(alpha_hat))) == ",1]")]
alpha_hat2 <- alpha_hat[which(substr(names(alpha_hat), nchar(names(alpha_hat))-2, nchar(names(alpha_hat))) == ",2]")]

mean(alpha_hat1)
mean(alpha_hat2)
par(mfrow = c(1, 2), mar = c(5, 4, 4, 2), oma = c(1, 1, .25, .25))
plot((simulated_data$params$gamma_rc[,1] + simulated_data$params$beta[1]) ~ alpha_hat1,
     xlab = "Cause 1",
     ylab = "True alphas", 
     main = "Posterior median of the alphas",
     pch = 19, col = alpha("dodgerblue", 0.5))
abline(0, 1, col = "darkgreen")
plot((simulated_data$params$gamma_rc[,2] + simulated_data$params$beta[2]) ~ alpha_hat2,
     xlab = "Cause 2",
     ylab = "True alphas", 
     pch = 19, col = alpha("indianred", 0.5))
abline(0, 1, col = "darkgreen")
```

\newpage

### Data dimensions: R = 8, I = 1, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma 1} = 1.5$
- $\sigma_{\gamma 2} = 2.5$
- $\rho = 0.5$

Simulate data and run model:

```{r mod9-3, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 8
number_of_replications <- 1
model_to_run <-  "2 cause FE, bivariate region IID RE"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = c(1.5, 2.5),
                               rho_gamma = 0.5,
                               seed = 111,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5,
                     max_treedepth = 25, adapt_delta = 0.95)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))
```

```{r mod9-3-est-plots, warning = TRUE, cache = FALSE}
# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma", "Omega[1,2]"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma", "Lcorr[2,1]", "Lcorr[2,2]"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma", "Lcorr[2,1]", "Lcorr[2,2]"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", 
                    "sigma_gamma[1]", "sigma_gamma[2]",
                    "Lcorr[2,1]", "Lcorr[2,2]"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
alpha_hat <- summary(stan_list$mod_stan, 
                     pars = c("alpha"), probs = 0.5)$summary[, "50%"]

alpha_hat1 <- alpha_hat[which(substr(names(alpha_hat), nchar(names(alpha_hat))-2, nchar(names(alpha_hat))) == ",1]")]
alpha_hat2 <- alpha_hat[which(substr(names(alpha_hat), nchar(names(alpha_hat))-2, nchar(names(alpha_hat))) == ",2]")]

mean(alpha_hat1)
mean(alpha_hat2)
par(mfrow = c(1, 2), mar = c(5, 4, 4, 2), oma = c(1, 1, .25, .25))
plot((simulated_data$params$gamma_rc[,1] + simulated_data$params$beta[1]) ~ alpha_hat1,
     xlab = "Cause 1",
     ylab = "True alphas", 
     main = "Posterior median of the alphas",
     pch = 19, col = alpha("dodgerblue", 0.5))
abline(0, 1, col = "darkgreen")
plot((simulated_data$params$gamma_rc[,2] + simulated_data$params$beta[2]) ~ alpha_hat2,
     xlab = "Cause 2",
     ylab = "True alphas", 
     pch = 19, col = alpha("indianred", 0.5))
abline(0, 1, col = "darkgreen")
```

\newpage

## Model 9b: non-centered parameterization

We will fit a model with a non-centered parameterization to see if HMC behavior is better in this case. The model we fit is

\eq{
    \bm{y}_{ir} | \bm\mu_{ir}, \bm{V}_{ir} &\sim N_2(\bm\mu_{ir}, \bm{V}_{ir}) \\
    \mu_{ir1} &= \beta_1 + \gamma_{1r} \\
    \mu_{ir2} &= \beta_2 + \gamma_{2r} \\
    (\gamma_{1r}, \gamma_{2r}) &= (\gamma^*_{1r}, \gamma^*_{2r}) \bm{D}^T \\
    \Sigma_{\gamma} &= \bm{D}\bm{D}^T \text{ (Cholesky decomposition)} \\
    &= \bm{S} \Omega \bm{S} \\
    \bm{S} &= \begin{bmatrix} \sigma_{\gamma 1} & 0 \\ 0 & \sigma_{\gamma 2} \end{bmatrix} \\
    \Omega &= \begin{bmatrix} 1 & \rho_{\gamma} \\ \rho_{\gamma} & 1 \end{bmatrix} \\
    \gamma^*_{1r} &\sim N(0,1) \\
    \gamma^*_{2r} &\sim N(0,1)
}

Priors:

\eq{
    \beta_c &\sim N(0, 5) \forall c \\
    \sigma_{\gamma 1} &\sim \mbox{Half-t}_{\mbox{df = 3}}(0, 1) \\
    \sigma_{\gamma 2} &\sim \mbox{Half-t}_{\mbox{df = 3}}(0, 1) \\
    \Omega &= \bm{L}\bm{L}^T \text{ (Cholesky decomposition)} \\
    L &\sim \mbox{LKJ}(1)
}

STAN model code is:

\begin{verbatim}
data {
    int<lower=1> N; // number of bivariate normal observations (=I*R)
    int<lower=1> R; // number of regions
    int<lower=1> regions[N]; // index for which region is for which bivariate observation
    matrix[2, 2] Sigma[N]; // fixed block diagonal matrix of covariances for each observed pair
    vector[2] y[N]; // outcome
}
parameters {
    vector<lower=0>[2] sigma_gamma; // standard deviations of the IID REs on region
    matrix[R, 2] gamma_star; // REs on region (bivariate), on normal(0,1) scale to be transformed
    vector[2] beta; // FEs on cause
    cholesky_factor_corr[2] Lcorr;// cholesky factor (L_u matrix for Omega)
}
transformed parameters {
    vector[2] mu[N]; // means of bivariate normal obs
    corr_matrix[2] Omega; // correlation matrix for REs
    cov_matrix[2] V; // covaraince matrix for REs
    matrix[R, 2] gamma_mat; // alphas in matrix form
    matrix[2, 2] L; // cholesky decomposition of V
    
    Omega = multiply_lower_tri_self_transpose(Lcorr);
    V = quad_form_diag(Omega, sigma_gamma); // quad_form_diag: diag_matrix(sig) * R * diag_matrix(sig)
    L = cholesky_decompose(V);
    gamma_mat = gamma_star * L'; // b in matrix form
    for (i in 1:N) {
         mu[i] = beta + to_vector(gamma_mat[regions[i], ]); //
    }
}
model {
    for (i in 1:N) {
        y[i] ~ multi_normal(mu[i], Sigma[i]); // bivariate normal observations
    }
    to_vector(gamma_star) ~ normal(0, 1); // IID normal REs on region
    Lcorr ~ lkj_corr_cholesky(1); 
    sigma_gamma ~ student_t(3,0,1); // leads to a half t prior
    beta ~ normal(0,5); 
}
\end{verbatim}

### Data dimensions: R = 30, I = 10, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma 1} = 1.5$
- $\sigma_{\gamma 2} = 2.5$
- $\rho = 0.5$

Simulate data and run model:

```{r mod9b-1, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 30
number_of_replications <- 10
model_to_run <-  "2 cause FE, bivariate region IID RE noncentered"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = c(1.5, 2.5),
                               rho_gamma = 0.5,
                               seed = 111,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5,
                     max_treedepth = 15, adapt_delta = 0.8)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))
```

```{r mod9b-1-est-plots, warning = TRUE, cache = FALSE}
# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma", "Omega[1,2]"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma", "Lcorr[2,1]", "Lcorr[2,2]"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma", "Lcorr[2,1]", "Lcorr[2,2]"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", 
                    "sigma_gamma[1]", "sigma_gamma[2]",
                    "Lcorr[2,1]", "Lcorr[2,2]"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
gamma_hat <- summary(stan_list$mod_stan, 
                     pars = c("gamma_mat"), probs = 0.5)$summary[, "50%"]

gamma_hat1 <- gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")]
gamma_hat2 <- gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")]

mean(gamma_hat1)
mean(gamma_hat2)
par(mfrow = c(1, 2), mar = c(5, 4, 4, 2), oma = c(1, 1, .25, .25))
plot(simulated_data$params$gamma_rc[,1] ~ gamma_hat1,
     xlab = "Cause 1",
     ylab = "True gammas", 
     main = "Posterior median of the gammas",
     pch = 19, col = alpha("dodgerblue", 0.5))
abline(0, 1, col = "darkgreen")
plot(simulated_data$params$gamma_rc[,2] ~ gamma_hat2,
     xlab = "Cause 2",
     ylab = "True gammas", 
     pch = 19, col = alpha("indianred", 0.5))
abline(0, 1, col = "darkgreen")
```

\newpage

### Data dimensions: R = 100, I = 1, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma 1} = 1.5$
- $\sigma_{\gamma 2} = 2.5$
- $\rho = 0.5$

Simulate data and run model:

```{r mod9b-2, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 100
number_of_replications <- 1
model_to_run <-  "2 cause FE, bivariate region IID RE noncentered"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = c(1.5, 2.5),
                               rho_gamma = 0.5,
                               seed = 111,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5,
                     max_treedepth = 15, adapt_delta = 0.8)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))
```

```{r mod9b-2-est-plots, warning = TRUE, cache = FALSE}
# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma", "Omega[1,2]"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma", "Lcorr[2,1]", "Lcorr[2,2]"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma", "Lcorr[2,1]", "Lcorr[2,2]"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", 
                    "sigma_gamma[1]", "sigma_gamma[2]",
                    "Lcorr[2,1]", "Lcorr[2,2]"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
gamma_hat <- summary(stan_list$mod_stan, 
                     pars = c("gamma_mat"), probs = 0.5)$summary[, "50%"]

gamma_hat1 <- gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")]
gamma_hat2 <- gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")]

mean(gamma_hat1)
mean(gamma_hat2)
par(mfrow = c(1, 2), mar = c(5, 4, 4, 2), oma = c(1, 1, .25, .25))
plot(simulated_data$params$gamma_rc[,1] ~ gamma_hat1,
     xlab = "Cause 1",
     ylab = "True gammas", 
     main = "Posterior median of the gammas",
     pch = 19, col = alpha("dodgerblue", 0.5))
abline(0, 1, col = "darkgreen")
plot(simulated_data$params$gamma_rc[,2] ~ gamma_hat2,
     xlab = "Cause 2",
     ylab = "True gammas", 
     pch = 19, col = alpha("indianred", 0.5))
abline(0, 1, col = "darkgreen")
```

\newpage

### Data dimensions: R = 8, I = 1, C = 2

Parameter values

- $\bm\beta = (1, 2)$
- $\sigma^2_{c,ir} \sim \mbox{Unif}(0.05, 0.5)$
- $\rho_{12,ir} \sim \mbox{Unif}(-0.2, 0.2)$
- $\sigma_{\gamma 1} = 1.5$
- $\sigma_{\gamma 2} = 2.5$
- $\rho = 0.5$

Simulate data and run model:

```{r mod9b-3, warning = TRUE}
number_of_causes <- 2
number_of_regions <- 8
number_of_replications <- 1
model_to_run <-  "2 cause FE, bivariate region IID RE noncentered"
simulated_data <- simulateData(R = number_of_regions, 
                               I = number_of_replications, 
                               C = number_of_causes,
                               beta = 1:number_of_causes, 
                               rho_lower = -0.2, rho_upper = 0.2, 
                               sigmasq_lower = 0.05, sigmasq_upper = 0.5,
                               sigma_gamma = c(1.5, 2.5),
                               rho_gamma = 0.5,
                               seed = 111,
                               dgm = model_to_run)

stan_list <- fitSTAN(model_to_run, simulated_data$datlist,
                     niter = 10000, nchains = 2, nthin = 1, prop_warmup = 0.5,
                     max_treedepth = 15, adapt_delta = 0.8)

# report time
if (stan_list$elapsed_time <= 60) {
    time_report <- paste(stan_list$elapsed_time, "sec")
} else if (stan_list$elapsed_time/60 <= 60) {
    time_report <- paste(stan_list$elapsed_time/60, "min")
} else {
    time_report <- paste(stan_list$elapsed_time/60/60, "hours")
}
cat(paste("Elapsed time:", time_report))
```

```{r mod9b-3-est-plots, warning = TRUE, cache = FALSE}
# posterior estimates
mod_summary <- summary(stan_list$mod_stan, 
                       pars = c("beta", "sigma_gamma", "Omega[1,2]"),
                       probs = c(0.1, 0.9))
mod_summary$summary

# make diagnostic plots
stan_trace(stan_list$mod_stan, pars = c("beta", "sigma_gamma", "Lcorr[2,1]", "Lcorr[2,2]"))
pairs(stan_list$mod_stan, pars = c("beta", "sigma_gamma", "Lcorr[2,1]", "Lcorr[2,2]"))
mcmc_areas(as.matrix(stan_list$mod_stan),
           pars = c("beta[1]", "beta[2]", 
                    "sigma_gamma[1]", "sigma_gamma[2]",
                    "Lcorr[2,1]", "Lcorr[2,2]"),
           prob = 0.8)
mcmc_nuts_energy(nuts_params(stan_list$mod_stan))

# plot gammas vs posterior median gamma-hat
gamma_hat <- summary(stan_list$mod_stan, 
                     pars = c("gamma_mat"), probs = 0.5)$summary[, "50%"]

gamma_hat1 <- gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",1]")]
gamma_hat2 <- gamma_hat[which(substr(names(gamma_hat), nchar(names(gamma_hat))-2, nchar(names(gamma_hat))) == ",2]")]

mean(gamma_hat1)
mean(gamma_hat2)
par(mfrow = c(1, 2), mar = c(5, 4, 4, 2), oma = c(1, 1, .25, .25))
plot(simulated_data$params$gamma_rc[,1] ~ gamma_hat1,
     xlab = "Cause 1",
     ylab = "True gammas", 
     main = "Posterior median of the gammas",
     pch = 19, col = alpha("dodgerblue", 0.5))
abline(0, 1, col = "darkgreen")
plot(simulated_data$params$gamma_rc[,2] ~ gamma_hat2,
     xlab = "Cause 2",
     ylab = "True gammas", 
     pch = 19, col = alpha("indianred", 0.5))
abline(0, 1, col = "darkgreen")
```

\newpage
